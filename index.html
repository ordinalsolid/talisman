<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Talisman Agency (Fuck Yes)</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Stylish&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-color: #000000;
      --sidebar-bg: #f4f4f4;
      --accent: #333; 
      --highlight: #8e44ad;
      --text-main: #333;
      --border-color: #ddd;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      /* 2. APPLY FONT TO UI */
      font-family: 'Stylish', sans-serif;
      background: var(--bg-color);
      height: 100vh;
      overflow: hidden; 
      padding: 0;
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      cursor: none; 
    }
    
    /* --- CUSTOM CURSOR GLOW --- */
    #cursor-glow {
      position: fixed;
      top: 0; left: 0; width: 60px; height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(142, 68, 173, 0.6) 0%, rgba(142, 68, 173, 0) 70%);
      pointer-events: none; z-index: 9999;
      transform: translate(-50%, -50%);
      transition: opacity 0.2s ease;
      mix-blend-mode: screen; 
    }
    body:hover #cursor-glow { opacity: 1; }
    
    .header {
      background: #111; padding: 15px 20px;
      display: flex; justify-content: space-between; align-items: center;
      border-bottom: 1px solid #333; flex-shrink: 0; z-index: 10; color: #fff;
    }
    .header h1 { font-size: 1.5rem; letter-spacing: 1px; text-transform: uppercase; font-weight: 400;}
    
    .main { display: flex; flex: 1; overflow: hidden; position: relative; flex-direction: row; }
    
    /* --- SIDEBAR --- */
    .sidebar {
      width: 340px; background: var(--sidebar-bg); border-right: 1px solid #333;
      display: flex; flex-direction: column; flex-shrink: 0; z-index: 2; order: 1; height: 100%;
    }
    
    .sidebar-content { flex: 1; overflow-y: auto; cursor: default; }

    .accordion-item { border-bottom: 1px solid var(--border-color); background: #fff; }
    .accordion-header {
      width: 100%; text-align: left; background: #fff; padding: 20px;
      border: none; outline: none; cursor: pointer;
      /* Update header font size slightly for Stylish font readability */
      font-family: 'Stylish', sans-serif;
      font-size: 1.1rem; 
      font-weight: 400; letter-spacing: 1px; color: #444;
      display: flex; justify-content: space-between; align-items: center;
      text-transform: uppercase; min-height: 60px; 
    }
    .accordion-header:hover { background: #f9f9f9; }
    .accordion-header::after { content: '+'; font-size: 1.2rem; font-weight: 300; color: #888; }
    .accordion-item.active .accordion-header::after { content: '-'; }
    
    .accordion-body { max-height: 0; overflow: hidden; transition: max-height 0.4s cubic-bezier(0.25, 1, 0.5, 1); background: #fafafa; }
    .accordion-inner { padding: 20px; border-top: 1px solid #eee; }
    .accordion-item.disabled { pointer-events: none; opacity: 0.5; }

    /* --- FORM ELEMENTS --- */
    .text-input { 
        width: 100%; padding: 12px; border: 1px solid #ccc; border-radius: 6px; 
        font-family: 'Stylish', sans-serif; font-size: 1.1rem; 
    }
    .slider-row { margin-bottom: 15px; }
    .slider-row label { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 1rem; color: #555;}
    input[type="range"] { width: 100%; accent-color: var(--accent); height: 6px; cursor: pointer; }
    
    .btn { 
        width: 100%; padding: 12px; border: none; border-radius: 6px; 
        font-family: 'Stylish', sans-serif; font-size: 1.1rem; 
        cursor: pointer; text-transform: uppercase; margin-bottom: 10px; 
    }
    .btn-primary { background: #333; color: white; margin-top: 10px; }
    .btn-secondary { background: #e0e0e0; color: #333; }
    
    .upload-btn-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; margin-bottom: 15px; }
    .upload-btn-wrapper input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; height: 100%; }

    .assets-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    .asset-item { aspect-ratio: 1; background: #fff; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 4px; position: relative; }
    .asset-item img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
    .asset-item.selected { border-color: var(--highlight); background: #f4ecf7; transform: scale(1.05); }
    
    /* --- CANVAS --- */
    .canvas-area {
      flex: 1; background: #000000; display: flex; align-items: center; justify-content: center;
      position: relative; overflow: hidden; order: 2; cursor: none; 
    }
    canvas { height: 96%; width: auto; max-width: 98%; object-fit: contain; }

    /* --- MOBILE --- */
    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .header { position: sticky; top: 0; z-index: 1000; background: rgba(17, 17, 17, 0.9); }
      .canvas-area { height: 50vh; flex: none; order: 1; padding: 10px; cursor: auto;}
      .sidebar { width: 100%; flex: 1; border-right: none; border-top: 1px solid #333; order: 2; }
      .assets-grid { grid-template-columns: repeat(5, 1fr); }
      #cursor-glow { display: none; } 
    }
  </style>
</head>
<body>

  <div id="cursor-glow"></div>

  <div class="header">
    <h1>Talisman Agency <small>Periapt for Devices</small></h1>
  </div>
  
  <div class="main">
    <div class="sidebar">
      <div class="sidebar-content">
        
        <div class="accordion-item" id="acc-intention">
          <button class="accordion-header" onclick="toggleAccordion('acc-intention')">I. Intention</button>
          <div class="accordion-body"><div class="accordion-inner">
             <input type="text" id="intentionInput" class="text-input" placeholder="Type intention..." maxlength="40">
          </div></div>
        </div>

        <div class="accordion-item" id="acc-formation">
          <button class="accordion-header" onclick="toggleAccordion('acc-formation')">II. Formation</button>
          <div class="accordion-body"><div class="accordion-inner">
              <div class="slider-row">
                <label>Cavities <span id="val-windows">4</span></label>
                <input type="range" id="windows" min="1" max="8" value="4" oninput="updateVal('windows', this.value); generateFullTalisman()">
              </div>
              <div class="slider-row">
                <label>Erosion <span id="val-roughness">0.0</span></label>
                <input type="range" id="roughness" min="0.0" max="1.0" step="0.01" value="0.0" oninput="updateVal('roughness', this.value); updateContourOnly()">
              </div>
              <button class="btn btn-primary" onclick="generateFullTalisman()">Reform Talisman</button>
          </div></div>
        </div>

        <div class="accordion-item" id="acc-selection">
          <button class="accordion-header" onclick="toggleAccordion('acc-selection')">III. Selection</button>
          <div class="accordion-body"><div class="accordion-inner">
              <div class="upload-btn-wrapper">
                <button class="btn btn-secondary">+ Upload Custom Sigil</button>
                <input type="file" id="fileUpload" accept="image/*" onchange="handleFileUpload(event)" />
              </div>
              <div class="assets-grid" id="assetGrid"></div>
          </div></div>
        </div>

        <div class="accordion-item disabled" id="acc-calibration">
          <button class="accordion-header" onclick="toggleAccordion('acc-calibration')">IV. Calibration</button>
          <div class="accordion-body"><div class="accordion-inner">
              <div class="slider-row"><label>Rotate</label><input type="range" id="sigilRot" min="-180" max="180" value="0"></div>
              <div class="slider-row"><label>Scale</label><input type="range" id="sigilScale" min="0.2" max="3.0" step="0.1" value="1.0"></div>
          </div></div>
        </div>

        <div class="accordion-item" id="acc-exportation">
          <button class="accordion-header" onclick="toggleAccordion('acc-exportation')">V. Exportation</button>
          <div class="accordion-body"><div class="accordion-inner">
              <button class="btn btn-secondary" onclick="exportImage()">Download</button>
              <button class="btn btn-secondary" onclick="clearAssets()" style="background:#fff; border:1px solid #ccc;">Clear Sigils</button>
          </div></div>
        </div>
      </div>
    </div>

    <div class="canvas-area">
      <canvas id="canvas" width="900" height="1500"></canvas>
    </div>
  </div>

  <script>
    // --- CONFIGURATION ---
    
 // 1. TEXTURES: List every file in your "Textures" folder here.
    const TEXTURE_FILENAMES = [
        'texture01.png',
        'texture02.png', 
        'texture03.png',
		'texture04.png',
        'texture05.png', 
        'texture06.png',
		'texture07.png',
        'texture08.png', 
        'texture09.png',
		'texture10.png',
        // Add more here: 'stone_granite.png', 'cracks.png', etc.
    ];

    // 2. SIGILS: List files in "assets" folder
    const SIGIL_FILENAMES = [
        'sg_0001.png', 'sg_0008b.png', 'sg_0023c.png', 'sg_0047a.png', 'sg_0055d.png', 'sg_0056b.png','sg_0058d.png', 'sg_0063a.png', 'sg_0067.png', 'sg_0070.png','sg_0072.png', 'sg_0078a.png', 'sg_0078f.png', 'sg_0080b.png', 'sg_0080c.png', 'sg_0085a.png', 'sg_0085b.png', 'sg_0086a.png','sg_0096a.png', 'sg_0096b.png', 'sg_0096h.png', 'sg_0097b.png','sg_0104c.png', 'sg_0104g.png', 'sg_0148.png', 'sg_0191.png'
    ];
    
    const TEXTURES_FOLDER = 'Textures/';
    const ASSETS_FOLDER = 'Spec_Geo_Assets/';

    // --- SYSTEM ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    // Blend modes for texture layering
    const BLEND_MODES = ['multiply', 'overlay', 'soft-light', 'hard-light', 'screen', 'darken'];

    let state = {
      talismanOutline: [], cavities: [], placedAssets: {}, 
      images: {}, 
      loadedTextures: [], 
      activeTextureStack: [], 
      intentionText: "", selectedAssetKey: null, activeCavityId: null, contourSeed: 0
    };

    // --- CURSOR ---
    const cursorGlow = document.getElementById('cursor-glow');
    document.addEventListener('mousemove', (e) => {
      cursorGlow.style.left = e.clientX + 'px'; cursorGlow.style.top = e.clientY + 'px';
    });

    // --- UTILS ---
    function toggleAccordion(id) {
      const item = document.getElementById(id);
      if(item.classList.contains('disabled')) return;
      const isActive = item.classList.contains('active');
      if(!isActive) {
          document.querySelectorAll('.accordion-item').forEach(el => {
              el.classList.remove('active'); el.querySelector('.accordion-body').style.maxHeight = null;
          });
          item.classList.add('active');
          const body = item.querySelector('.accordion-body');
          body.style.maxHeight = body.scrollHeight + "px";
      } else {
          item.classList.remove('active');
          item.querySelector('.accordion-body').style.maxHeight = null;
      }
    }
    
    function updateVal(id, val) { document.getElementById('val-'+id).textContent = val; }

    function smoothPoints(points, iterations=1) {
      let current = points;
      for(let k=0; k<iterations; k++) {
        const next = [];
        for (let i = 0; i < current.length; i++) {
          const prev = current[(i - 1 + current.length) % current.length];
          const pt = current[i];
          const nxt = current[(i + 1) % current.length];
          next.push({ x: (prev.x + pt.x + nxt.x) / 3, y: (prev.y + pt.y + nxt.y) / 3 });
        }
        current = next;
      }
      return current;
    }

    function isInside(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    
    function getBoundingBox(points) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        points.forEach(p => {
            if(p.x < minX) minX = p.x; if(p.y < minY) minY = p.y;
            if(p.x > maxX) maxX = p.x; if(p.y > maxY) maxY = p.y;
        });
        return { width: maxX - minX, height: maxY - minY, cx: minX + (maxX - minX)/2, cy: minY + (maxY - minY)/2 };
    }

    // --- GENERATION ---
    function generateCavityShape(cx, cy, avgSize) {
      const points = []; const steps = 40; 
      const stretch = 0.7 + Math.random() * 0.5;
      for (let i = 0; i < steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        const r = avgSize * (0.8 + Math.random() * 0.4);
        points.push({ x: cx + Math.cos(theta) * r, y: cy + Math.sin(theta) * r * stretch });
      }
      return smoothPoints(points, 2);
    }

    function updateContourOnly() {
        const erosion = parseFloat(document.getElementById('roughness').value);
        const cx = canvas.width / 2, cy = canvas.height / 2;
        const w = 350, h = 600;
        const points = [];
        
        for (let i = 0; i < 200; i++) {
            const a = (i / 200) * Math.PI * 2;
            let r = Math.pow(Math.pow(Math.abs(Math.cos(a))/(w), 4) + Math.pow(Math.abs(Math.sin(a))/(h), 4), -1/4);
            const noise = Math.sin(i * 0.2 + state.contourSeed) * 20;
            const erosionFactor = (Math.random() - 0.5) * (erosion * 100);
            points.push({ x: cx + Math.cos(a) * (r + noise - erosionFactor), y: cy + Math.sin(a) * (r + noise - erosionFactor) });
        }
        state.talismanOutline = smoothPoints(points, 3);
        render();
    }
    
    // --- TEXTURE MIXER ---
    function generateTextureStack() {
        if (state.loadedTextures.length === 0) {
            state.activeTextureStack = [];
            return;
        }

        const stack = [];
        // Pick 2 to 3 layers randomly
        const layersCount = 2 + Math.floor(Math.random() * 2); 
        
        for(let i=0; i<layersCount; i++) {
            const randTex = state.loadedTextures[Math.floor(Math.random() * state.loadedTextures.length)];
            const randMode = BLEND_MODES[Math.floor(Math.random() * BLEND_MODES.length)];
            const randOpacity = 0.3 + Math.random() * 0.5;
            
            stack.push({
                img: randTex,
                mode: randMode,
                opacity: randOpacity
            });
        }
        state.activeTextureStack = stack;
    }

    function generateFullTalisman() {
        state.contourSeed = Math.random() * 100;
        generateTextureStack();

        const num = parseInt(document.getElementById('windows').value);
        state.cavities = [];
        
        const cx = canvas.width / 2, cy = canvas.height / 2;
        for(let i=0; i<num; i++) {
            let placed = false, attempts = 0;
            while(!placed && attempts < 100) {
                const wx = cx + (Math.random()-0.5)*400;
                const wy = cy + (Math.random()-0.5)*800;
                const size = 60 + Math.random()*40;
                const safe = state.cavities.every(c => Math.hypot(c.x-wx, c.y-wy) > (c.size+size));
                if(safe) {
                    state.cavities.push({ id: Date.now()+i, x: wx, y: wy, size: size, shape: generateCavityShape(wx, wy, size) });
                    placed = true;
                }
                attempts++;
            }
        }
        updateContourOnly();
    }

    // --- RENDER ---
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (state.talismanOutline.length === 0) return;
      const pts = state.talismanOutline;

      // 1. Shadow
      ctx.save(); ctx.translate(15, 30); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.filter = 'blur(20px)';
      ctx.beginPath(); pts.forEach((p,i) => i==0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
      ctx.fill(); ctx.restore();

      // 2. Stone Body & Texture Stacking
      ctx.save();
      ctx.beginPath(); pts.forEach((p,i) => i==0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
      ctx.clip();
      
      // Base Color
      ctx.fillStyle = '#444'; ctx.fillRect(0,0,canvas.width, canvas.height);
      
      // Apply Texture Stack
      if(state.activeTextureStack.length > 0) {
          state.activeTextureStack.forEach(layer => {
              ctx.globalCompositeOperation = layer.mode;
              ctx.globalAlpha = layer.opacity;
              ctx.drawImage(layer.img, 0, 0, canvas.width, canvas.height);
          });
      } else {
          // Fallback if no textures found
          const grad = ctx.createRadialGradient(canvas.width/2-100, canvas.height/2-100, 50, canvas.width/2, canvas.height/2, 800);
          grad.addColorStop(0, '#666'); grad.addColorStop(1, '#222');
          ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height);
      }
      
      // Reset
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      
      // Edge Shadow Vignette
      const gradV = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 300, canvas.width/2, canvas.height/2, 800);
      gradV.addColorStop(0, 'rgba(0,0,0,0)'); gradV.addColorStop(1, 'rgba(0,0,0,0.8)');
      ctx.fillStyle = gradV; ctx.fillRect(0,0,canvas.width, canvas.height);

      ctx.restore();

      // 3. Cavities
      state.cavities.forEach(c => {
         ctx.save();
         ctx.beginPath(); c.shape.forEach((p,i) => i==0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
         ctx.fillStyle = '#050505'; ctx.fill();
         ctx.strokeStyle = (state.activeCavityId === c.id) ? '#8e44ad' : 'rgba(255,255,255,0.2)';
         ctx.lineWidth = (state.activeCavityId === c.id) ? 3 : 1;
         ctx.stroke();
         
         const asset = state.placedAssets[c.id];
         if(asset && state.images[asset.key]) {
             ctx.clip();
             const img = state.images[asset.key];
             const bounds = getBoundingBox(c.shape);
             const scale = Math.min(bounds.width/img.width, bounds.height/img.height) * asset.scale * 0.8;
             
             ctx.translate(bounds.cx, bounds.cy);
             ctx.rotate(asset.rot * Math.PI/180);
             ctx.drawImage(img, -img.width*scale/2, -img.height*scale/2, img.width*scale, img.height*scale);
         }
         ctx.restore();
      });
      
      // 4. Intention Text (UPDATED FONT)
      if(state.intentionText) {
          // 3. APPLY FONT TO CANVAS TEXT
          ctx.font = '34px "Stylish", sans-serif'; 
          ctx.fillStyle = '#aaa'; 
          ctx.textAlign = 'center'; 
          ctx.fillText(state.intentionText.toUpperCase(), canvas.width/2, canvas.height - 50);
      }
    }

    // --- ASSETS ---
    function loadSingleAsset(key, src, isCustom=false) {
        const img = new Image();
        img.crossOrigin = "Anonymous"; 
        img.src = src;
        img.onload = () => {
            state.images[key] = img;
            const div = document.createElement('div');
            div.className = 'asset-item' + (isCustom ? ' custom' : '');
            div.dataset.id = key;
            div.onclick = () => selectAsset(key);
            div.innerHTML = `<img src="${src}">`;
            document.getElementById('assetGrid').appendChild(div);
        };
    }

    function initAssets() {
        // 1. Load TEXTURES
        TEXTURE_FILENAMES.forEach(filename => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = TEXTURES_FOLDER + filename;
            img.onload = () => {
                state.loadedTextures.push(img);
                if(state.loadedTextures.length === 1) generateTextureStack(); render();
            };
        });
        
        // 2. Load SIGILS
        SIGIL_FILENAMES.forEach((filename, i) => {
            loadSingleAsset('sigil_'+i, ASSETS_FOLDER + filename);
        });

        // 3. Load Saved Customs
        try {
            const saved = localStorage.getItem('talisman_custom_v3');
            if(saved) JSON.parse(saved).forEach(item => loadSingleAsset(item.id, item.src, true));
        } catch(e){}
    }
    
    // --- INTERACTION ---
    function selectAsset(key) {
        state.selectedAssetKey = key;
        document.querySelectorAll('.asset-item').forEach(el => el.classList.remove('selected'));
        const active = document.querySelector(`.asset-item[data-id="${key}"]`);
        if(active) active.classList.add('selected');
    }

    canvas.addEventListener('mousedown', handleInteract);
    canvas.addEventListener('touchstart', handleInteract);
    
    function handleInteract(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        const x = (clientX - rect.left) * (canvas.width / rect.width);
        const y = (clientY - rect.top) * (canvas.height / rect.height);

        const hit = state.cavities.find(c => isInside(x, y, c.shape));
        if(hit) {
            if(state.selectedAssetKey) {
                state.placedAssets[hit.id] = { key: state.selectedAssetKey, rot: 0, scale: 1.0 };
                render();
            }
            state.activeCavityId = hit.id;
            const acc = document.getElementById('acc-calibration');
            acc.classList.remove('disabled');
            if(!acc.classList.contains('active')) toggleAccordion('acc-calibration');
            render();
        } else {
            state.activeCavityId = null;
            render();
        }
    }
    
    document.getElementById('sigilRot').addEventListener('input', (e) => {
        if(state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            state.placedAssets[state.activeCavityId].rot = parseInt(e.target.value); render();
        }
    });
    document.getElementById('sigilScale').addEventListener('input', (e) => {
        if(state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            state.placedAssets[state.activeCavityId].scale = parseFloat(e.target.value); render();
        }
    });
    document.getElementById('intentionInput').addEventListener('input', (e) => {
        state.intentionText = e.target.value; render();
    });
    
    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const id = 'custom_' + Date.now();
            loadSingleAsset(id, evt.target.result, true);
        };
        reader.readAsDataURL(file);
    }

    function exportImage() {
        const link = document.createElement('a');
        link.download = 'talisman.png';
        link.href = canvas.toDataURL();
        link.click();
    }
    
    function clearAssets() { state.placedAssets = {}; render(); }

    initAssets();
    generateFullTalisman();

    // Check if the font loads slowly and re-render once active
    document.fonts.ready.then(function() {
      render();
    });

  </script>
</body>
</html>