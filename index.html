<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Talisman Agency v19 (Sigil Tuning)</title>
  <style>
    :root {
      --bg-color: #000000;
      --sidebar-bg: #f4f4f4;
      --panel-bg: #fff;
      --accent: #333; 
      --highlight: #8e44ad;
      --text-main: #333;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: var(--bg-color);
      height: 100vh;
      overflow: hidden; 
      padding: 0;
      color: var(--text-main);
      display: flex;
      flex-direction: column;
    }
    
    .header {
      background: #111;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
      flex-shrink: 0;
      z-index: 10;
      color: #fff;
    }

    .header h1 { font-size: 1.1rem; letter-spacing: 2px; text-transform: uppercase; font-weight: 400;}
    .header small { font-size: 0.7rem; color: #888; }
    
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
      flex-direction: row; 
    }
    
    .sidebar {
      width: 340px;
      background: var(--sidebar-bg);
      padding: 25px;
      overflow-y: auto;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 20px;
      flex-shrink: 0;
      z-index: 2;
      order: 1;
    }
    
    .explainer-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: #666;
      margin-bottom: 10px;
      border-left: 3px solid #333;
      padding-left: 10px;
    }
    
    .control-group {
      background: var(--panel-bg);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      transition: opacity 0.2s;
    }
    
    .control-group.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .control-group h3 {
      font-size: 0.75rem;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 12px;
      letter-spacing: 0.5px;
      font-weight: 700;
    }

    .text-input {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 1rem;
      background: #fafafa;
    }
    
    .slider-row { margin-bottom: 15px; }
    .slider-row label { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; color: #555;}
    input[type="range"] { width: 100%; accent-color: var(--accent); height: 6px; }
    
    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 8px;
      text-transform: uppercase;
      transition: all 0.2s;
      text-align: center;
    }
    
    .btn-primary { background: #333; color: white; }
    .btn-primary:hover { background: #000; }
    .btn-secondary { background: #e0e0e0; color: #333; }
    
    .upload-btn-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
      width: 100%;
      margin-bottom: 15px;
    }
    
    .upload-btn-wrapper input[type=file] {
      font-size: 100px;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      cursor: pointer;
      height: 100%;
    }

    .assets-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    
    .asset-item {
      aspect-ratio: 1;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      transition: all 0.2s;
      position: relative;
    }
    
    .asset-item img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
    
    .asset-item.custom::after {
      content: '•';
      position: absolute;
      top: 2px;
      right: 4px;
      color: var(--highlight);
      font-size: 1.2rem;
      line-height: 0.5;
    }

    .asset-item.selected {
      border-color: var(--highlight);
      background: #f4ecf7;
      transform: scale(1.05);
      box-shadow: 0 4px 8px rgba(142, 68, 173, 0.2);
    }
    
    .canvas-area {
      flex: 1;
      background: #000000; 
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      order: 2;
      padding: 10px; 
    }
    
    canvas {
      box-shadow: 0 0 100px rgba(255,255,255,0.05); 
      max-height: 98%; 
      max-width: 98%;
      object-fit: contain;
    }

    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .canvas-area { height: 55vh; flex: none; padding: 10px; order: 1; }
      .sidebar { width: 100%; height: auto; flex: 1; border-right: none; border-top: 1px solid #333; order: 2; }
      .assets-grid { grid-template-columns: repeat(5, 1fr); }
    }
  </style>
</head>
<body>

  <div class="header">
    <h1>Talisman Agency <small>v19</small></h1>
  </div>
  
  <div class="main">
    
    <div class="sidebar">
      <div class="explainer-text">
        <strong>How to use:</strong> 1. Select a sigil. 2. Tap a cavity to place it. 3. Tap the filled cavity again to unlock the rotation and scale sliders below.
      </div>

      <div class="control-group">
        <h3>1. Intention</h3>
        <input type="text" id="intentionInput" class="text-input" placeholder="Type intention here..." maxlength="40">
      </div>

      <div class="control-group">
        <h3>2. Formation</h3>
        <div class="slider-row">
          <label>Cavities <span id="val-windows">4</span></label>
          <input type="range" id="windows" min="1" max="8" value="4">
        </div>
        <div class="slider-row">
          <label>Erosion <span id="val-roughness">0.6</span></label>
          <input type="range" id="roughness" min="0.1" max="1.0" step="0.1" value="0.6">
        </div>
        <button class="btn btn-primary" onclick="generateTalisman()">Forge New Talisman</button>
      </div>

      <div class="control-group">
        <h3>3. Select Sigil</h3>
        
        <div class="upload-btn-wrapper">
          <button class="btn btn-secondary" style="margin-bottom:0;">+ Upload Custom Sigil</button>
          <input type="file" id="fileUpload" accept="image/png, image/jpeg, image/gif" onchange="handleFileUpload(event)" />
        </div>
        <div class="assets-grid" id="assetGrid"></div>
      </div>

      <div class="control-group disabled" id="tuningControls">
        <h3>4. Tune Sigil</h3>
        <div class="slider-row">
          <label>Rotate <span id="val-sigilRot">0°</span></label>
          <input type="range" id="sigilRot" min="-180" max="180" value="0">
        </div>
        <div class="slider-row">
          <label>Scale <span id="val-sigilScale">1.0</span></label>
          <input type="range" id="sigilScale" min="0.2" max="3.0" step="0.1" value="1.0">
        </div>
      </div>

      <div class="control-group">
        <button class="btn btn-secondary" onclick="exportImage()">Download Talisman</button>
        <button class="btn btn-secondary" onclick="clearAssets()" style="background:#fff; border:1px solid #ccc;">Clear Sigils</button>
      </div>
    </div>

    <div class="canvas-area">
      <canvas id="canvas" width="700" height="1000"></canvas>
    </div>

  </div>

  <script>
    /* ---------------- CONFIGURATION ---------------- */
    
    const assetFilenames = [
      'sg_0001.png', 'sg_0008b.png', 'sg_0023c.png', 'sg_0047a.png', 
      'sg_0055d.png', 'sg_0056b.png','sg_0058d.png', 'sg_0063a.png', 
      'sg_0067.png', 'sg_0070.png','sg_0072.png', 'sg_0078a.png', 
      'sg_0078f.png', 'sg_0080b.png', 'sg_0080c.png', 'sg_0085a.png', 
      'sg_0085b.png', 'sg_0086a.png','sg_0096a.png', 'sg_0096b.png', 
      'sg_0096h.png', 'sg_0097b.png','sg_0104c.png', 'sg_0104g.png', 
      'sg_0148.png', 'sg_0191.png'
    ];
    const ASSET_PATH = 'Spec_Geo_Assets/';
    const TEXTURE_COUNT = 10;
    const TEXTURE_PATH = 'Textures/';
    const LS_KEY = 'talisman_custom_assets_v1';

    /* ---------------- STATE ---------------- */
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    let state = {
      talismanOutline: [],
      cavities: [], 
      // Changed to object structure: id -> { key, rot, scale }
      placedAssets: {}, 
      images: {}, 
      customAssetsData: [], 
      textures: [], 
      activeTextures: [], 
      noiseCache: [],
      intentionText: "",
      selectedAssetKey: null,
      activeCavityId: null // The cavity currently being tuned
    };

    let draggedAssetKey = null; 

    function initNoise() {
      state.noiseCache = new Float32Array(1024);
      for(let i=0; i<1024; i++) state.noiseCache[i] = Math.random();
    }
    function noise(x, y) {
      const X = Math.floor(Math.abs(x)) & 1023;
      const Y = Math.floor(Math.abs(y)) & 1023;
      return state.noiseCache[X + state.noiseCache[Y] * 1023 & 1023]; 
    }

    // --- Generation Logic ---

    function generateTalismanShape(width, height, roughness, seedOffset) {
        const points = [];
        const steps = 150; 
        const cx = canvas.width / 2;
        const cy = canvas.height / 2 - 40; 
        
        const freq = 0.005; 
        
        for (let i = 0; i < steps; i++) {
            const t = i / steps;
            const angle = t * Math.PI * 2;
            const sx = Math.cos(angle) * width/2;
            const sy = Math.sin(angle) * height/2;
            
            let px = cx + Math.max(-width/2, Math.min(width/2, sx * 1.3));
            let py = cy + Math.max(-height/2, Math.min(height/2, sy * 1.3));
            
            const n1 = noise(px * freq + seedOffset, py * freq + seedOffset) - 0.5;
            const erosion = n1 * 80 * roughness;

            const dx = px - cx;
            const dy = py - cy;
            const dist = Math.hypot(dx, dy);
            points.push({ x: px + (dx/dist) * erosion, y: py + (dy/dist) * erosion });
        }
        return smoothPoints(points, 3);
    }

    function generateCavityShape(cx, cy, avgSize, roughness, seedOffset) {
      const points = [];
      const steps = 50; 
      const isOval = Math.random() > 0.4;
      const stretchX = isOval ? 0.7 + Math.random() * 0.6 : 1;
      const stretchY = isOval ? 0.7 + Math.random() * 0.6 : 1;
      const rotation = Math.random() * Math.PI;

      for (let i = 0; i < steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        let rx = Math.cos(theta) * avgSize * stretchX;
        let ry = Math.sin(theta) * avgSize * stretchY;
        if(isOval) {
            const rotX = rx * Math.cos(rotation) - ry * Math.sin(rotation);
            const rotY = rx * Math.sin(rotation) + ry * Math.cos(rotation);
            rx = rotX; ry = rotY;
        }
        const noiseFactor = isOval ? 0.2 : 0.8; 
        const n = noise(Math.cos(theta)*3 + seedOffset, Math.sin(theta)*3 + seedOffset);
        const distortion = 1 + (n - 0.5) * noiseFactor * roughness;
        points.push({ x: cx + rx * distortion, y: cy + ry * distortion });
      }
      return smoothPoints(points, isOval ? 2 : 1);
    }

    function smoothPoints(points, iterations=1) {
      let current = points;
      for(let k=0; k<iterations; k++) {
        const next = [];
        for (let i = 0; i < current.length; i++) {
          const prev = current[(i - 1 + current.length) % current.length];
          const pt = current[i];
          const nxt = current[(i + 1) % current.length];
          next.push({ x: (prev.x + pt.x + nxt.x) / 3, y: (prev.y + pt.y + nxt.y) / 3 });
        }
        current = next;
      }
      return current;
    }

    function isInside(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function distanceToPolyEdge(x, y, poly) {
        let minDist = Infinity;
        for (let i = 0; i < poly.length; i++) {
            const j = (i + 1) % poly.length;
            const p1 = poly[i]; const p2 = poly[j];
            let A = x - p1.x; let B = y - p1.y;
            let C = p2.x - p1.x; let D = p2.y - p1.y;
            let dot = A * C + B * D;
            let len_sq = C * C + D * D;
            let param = -1;
            if (len_sq != 0) param = dot / len_sq;
            let xx, yy;
            if (param < 0) { xx = p1.x; yy = p1.y; }
            else if (param > 1) { xx = p2.x; yy = p2.y; }
            else { xx = p1.x + param * C; yy = p1.y + param * D; }
            let dx = x - xx; let dy = y - yy;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if(dist < minDist) minDist = dist;
        }
        return minDist;
    }

    function getBoundingBox(points) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        points.forEach(p => {
            if(p.x < minX) minX = p.x; if(p.y < minY) minY = p.y;
            if(p.x > maxX) maxX = p.x; if(p.y > maxY) maxY = p.y;
        });
        return { width: maxX - minX, height: maxY - minY, cx: minX + (maxX - minX)/2, cy: minY + (maxY - minY)/2 };
    }

    function generateTalisman() {
      initNoise();
      const numCavities = parseInt(document.getElementById('windows').value);
      const roughness = parseFloat(document.getElementById('roughness').value);
      
      state.cavities = [];
      state.placedAssets = {}; 
      state.activeCavityId = null;
      updateTuningUI();

      if(state.textures.length > 0) {
        const t1 = Math.floor(Math.random() * state.textures.length);
        let t2 = Math.floor(Math.random() * state.textures.length);
        state.activeTextures = [state.textures[t1], state.textures[t2]];
      }

      const phoneWidth = canvas.width * 0.58; 
      const phoneHeight = canvas.height * 0.85; 
      
      state.talismanOutline = generateTalismanShape(phoneWidth, phoneHeight, roughness, Math.random() * 100);

      let attempts = 0;
      const bounds = {
          minX: canvas.width/2 - phoneWidth*0.33, maxX: canvas.width/2 + phoneWidth*0.33,
          minY: canvas.height/2 - 60 - phoneHeight*0.33, maxY: canvas.height/2 - 60 + phoneHeight*0.33
      };

      while (state.cavities.length < numCavities && attempts < 10000) {
        attempts++;
        let baseMin = 45; 
        let baseMax = 95;
        if (attempts > 2000) { baseMin = 35; baseMax = 70; }
        if (attempts > 5000) { baseMin = 25; baseMax = 50; }
        const wSize = baseMin + Math.random() * (baseMax - baseMin);
        const wx = bounds.minX + Math.random() * (bounds.maxX - bounds.minX);
        const wy = bounds.minY + Math.random() * (bounds.maxY - bounds.minY);
        if (state.cavities.some(c => Math.hypot(c.x - wx, c.y - wy) < (c.size + wSize) * 1.15)) continue;
        let shape = generateCavityShape(wx, wy, wSize, roughness, Math.random()*500);
        let safe = true;
        for(let pt of shape) {
            if(!isInside(pt.x, pt.y, state.talismanOutline)) { safe = false; break; }
            if(distanceToPolyEdge(pt.x, pt.y, state.talismanOutline) < 15) { safe = false; break; }
        }
        if (safe) {
            state.cavities.push({ id: Date.now() + attempts, x: wx, y: wy, size: wSize, shape: shape });
        }
      }
      render();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (state.talismanOutline.length === 0) return;

      const pts = state.talismanOutline;

      // 1. Shadow
      ctx.save();
      ctx.translate(10, 20);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.filter = 'blur(15px)';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // 2. Body
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      ctx.clip(); 
      ctx.fillStyle = '#666'; 
      ctx.fillRect(0,0,canvas.width, canvas.height);
      if(state.activeTextures.length > 0 && state.activeTextures[0]) {
        ctx.globalCompositeOperation = 'multiply';
        ctx.drawImage(state.activeTextures[0], 0, 0, canvas.width, canvas.height);
        if(state.activeTextures[1]) {
            ctx.globalCompositeOperation = 'soft-light';
            ctx.globalAlpha = 0.8;
            ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
            ctx.drawImage(state.activeTextures[1], 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
      }
      ctx.globalAlpha = 1.0; 
      
      // Lighting
      ctx.globalCompositeOperation = 'overlay';
      const bbox = getBoundingBox(pts);
      const grad = ctx.createRadialGradient(
          bbox.cx - bbox.width*0.2, bbox.cy - bbox.height*0.2, 50,
          bbox.cx, bbox.cy, bbox.height * 0.8
      );
      grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)'); 
      grad.addColorStop(0.5, 'rgba(128, 128, 128, 0.0)');
      grad.addColorStop(1, 'rgba(0, 0, 0, 0.6)');      
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore(); 

      // 3. Stroke
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      // 4. Cavities
      state.cavities.forEach(cavity => {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cavity.shape[0].x, cavity.shape[0].y);
        for(let p of cavity.shape) ctx.lineTo(p.x, p.y);
        ctx.closePath();
        
        ctx.fillStyle = '#000000';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Highlight Active Cavity
        if (state.activeCavityId === cavity.id) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#8e44ad'; // Purple highlight
            ctx.stroke();
        }

        ctx.restore();

        // Placed Assets with Rotation & Scale
        const assetData = state.placedAssets[cavity.id];
        if (assetData && state.images[assetData.key]) {
            const img = state.images[assetData.key];
            const bbox = getBoundingBox(cavity.shape);
            
            // Base fit scale
            const fitScaleX = (bbox.width * 0.75) / img.width;
            const fitScaleY = (bbox.height * 0.75) / img.height;
            const baseScale = Math.min(fitScaleX, fitScaleY);
            
            // Apply User Modifiers
            const finalScale = baseScale * assetData.scale;
            const drawW = img.width * finalScale;
            const drawH = img.height * finalScale;
            
            ctx.save();
            // Clip to cavity shape
            ctx.beginPath();
            ctx.moveTo(cavity.shape[0].x, cavity.shape[0].y);
            for(let p of cavity.shape) ctx.lineTo(p.x, p.y);
            ctx.clip(); 
            
            // Move to center, rotate, scale
            ctx.translate(bbox.cx, bbox.cy);
            ctx.rotate(assetData.rot * Math.PI / 180);
            
            ctx.globalAlpha = 0.9;
            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
            
            // Darken
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(-drawW/2, -drawH/2, drawW, drawH);
            
            ctx.restore();
        }
      });

      // 5. Text
      if(state.intentionText) {
          ctx.font = '14px Helvetica, Arial, sans-serif';
          ctx.fillStyle = '#888'; 
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom'; 
          ctx.letterSpacing = '1px';
          ctx.fillText(state.intentionText.toUpperCase(), canvas.width/2, canvas.height - 30);
      }
    }

    // --- Interaction ---

    function selectAsset(filename) {
        state.selectedAssetKey = filename;
        draggedAssetKey = filename; 
        document.querySelectorAll('.asset-item').forEach(el => el.classList.remove('selected'));
        const active = document.querySelector(`.asset-item[data-id="${filename}"]`);
        if(active) active.classList.add('selected');
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const customId = 'custom_' + Date.now();
        saveCustomAsset(customId, e.target.result);
        loadSingleAsset(customId, e.target.result, true); 
      };
      reader.readAsDataURL(file);
      event.target.value = ''; 
    }

    function saveCustomAsset(id, dataUrl) {
        state.customAssetsData.push({ id: id, src: dataUrl });
        try { localStorage.setItem(LS_KEY, JSON.stringify(state.customAssetsData)); } catch (e) {}
    }

    // --- Tuning Logic ---
    function updateTuningUI() {
        const group = document.getElementById('tuningControls');
        const rotSlider = document.getElementById('sigilRot');
        const scaleSlider = document.getElementById('sigilScale');
        
        if (state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            group.classList.remove('disabled');
            const data = state.placedAssets[state.activeCavityId];
            rotSlider.value = data.rot;
            scaleSlider.value = data.scale;
            document.getElementById('val-sigilRot').textContent = data.rot + '°';
            document.getElementById('val-sigilScale').textContent = data.scale;
        } else {
            group.classList.add('disabled');
        }
    }

    // Listeners for sliders
    document.getElementById('sigilRot').addEventListener('input', (e) => {
        if(state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            state.placedAssets[state.activeCavityId].rot = parseInt(e.target.value);
            document.getElementById('val-sigilRot').textContent = e.target.value + '°';
            render();
        }
    });

    document.getElementById('sigilScale').addEventListener('input', (e) => {
        if(state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            state.placedAssets[state.activeCavityId].scale = parseFloat(e.target.value);
            document.getElementById('val-sigilScale').textContent = e.target.value;
            render();
        }
    });


    function handleCanvasInteraction(e) {
      e.preventDefault(); 
      const rect = canvas.getBoundingClientRect();
      
      let clientX, clientY;
      if (e.changedTouches && e.changedTouches.length > 0) {
        clientX = e.changedTouches[0].clientX;
        clientY = e.changedTouches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      
      const target = state.cavities.find(c => isInside(x, y, c.shape));
      
      if (target) {
          // If we have a selected asset, place it
          if (state.selectedAssetKey) {
              // Place new or replace existing
              state.placedAssets[target.id] = { 
                  key: state.selectedAssetKey, 
                  rot: 0, 
                  scale: 1.0 
              };
              state.selectedAssetKey = null; // consume selection
              document.querySelectorAll('.asset-item').forEach(el => el.classList.remove('selected'));
              
              state.activeCavityId = target.id; // Select for tuning immediately
              updateTuningUI();
              render();
          } 
          // If no asset selected, just select the cavity (if it has something)
          else if (state.placedAssets[target.id]) {
              state.activeCavityId = target.id;
              updateTuningUI();
              render();
          }
      } else {
          // Clicked background -> deselect cavity
          state.activeCavityId = null;
          updateTuningUI();
          render();
      }
    }

    function loadSingleAsset(id, src, isCustom = false) {
        const grid = document.getElementById('assetGrid');
        const img = new Image();
        img.src = src;
        img.onload = () => { 
            state.images[id] = img;
            if(isCustom) selectAsset(id);
            render(); 
        };

        const div = document.createElement('div');
        div.className = 'asset-item' + (isCustom ? ' custom' : '');
        div.dataset.id = id;
        div.draggable = true;
        const thumb = document.createElement('img');
        thumb.src = src;
        div.appendChild(thumb);

        div.addEventListener('click', () => { selectAsset(id); });
        if(isCustom && grid.firstChild) grid.insertBefore(div, grid.firstChild);
        else grid.appendChild(div);
    }

    function loadResources() {
      const grid = document.getElementById('assetGrid');
      grid.innerHTML = '';
      try {
        const saved = localStorage.getItem(LS_KEY);
        if (saved) {
            state.customAssetsData = JSON.parse(saved);
            state.customAssetsData.forEach(asset => loadSingleAsset(asset.id, asset.src, true));
        }
      } catch (e) {}

      assetFilenames.forEach(filename => loadSingleAsset(filename, ASSET_PATH + filename, false));

      let texturesLoaded = 0;
      for(let i=1; i<=TEXTURE_COUNT; i++) {
        const num = i.toString().padStart(2, '0');
        const img = new Image();
        img.src = `${TEXTURE_PATH}texture${num}.png`;
        img.onload = () => {
            state.textures.push(img);
            texturesLoaded++;
            if(texturesLoaded === 2) generateTalisman();
        };
        img.onerror = () => {};
      }
    }

    canvas.addEventListener('click', handleCanvasInteraction);
    canvas.addEventListener('touchstart', handleCanvasInteraction, {passive: false});
    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => { e.preventDefault(); handleCanvasInteraction(e); });

    document.getElementById('intentionInput').addEventListener('input', (e) => {
        state.intentionText = e.target.value;
        render();
    });

    document.querySelectorAll('input[type=range]').forEach(el => {
      if(el.id === 'sigilRot' || el.id === 'sigilScale') return; // Handled separately
      el.addEventListener('input', (e) => {
        document.getElementById('val-' + e.target.id).textContent = e.target.value;
        generateTalisman();
      })
    });

    function clearAssets() { state.placedAssets = {}; state.activeCavityId = null; updateTuningUI(); render(); }
    function exportImage() {
        // Temporarily clear active selection ring for screenshot
        const temp = state.activeCavityId;
        state.activeCavityId = null; 
        render();
        
        const link = document.createElement('a');
        link.download = `Talisman.png`;
        link.href = canvas.toDataURL();
        link.click();
        
        // Restore
        state.activeCavityId = temp;
        render();
    }

    loadResources();
    setTimeout(() => { if(state.talismanOutline.length === 0) generateTalisman(); }, 1500);
  </script>
</body>
</html>