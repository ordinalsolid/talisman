<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spec_Geo Glyph Creator</title>
  <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #1a1c2c 0%, #4a192c 100%);
      --panel-bg: rgba(255, 255, 255, 0.95);
      --accent: #ff4757;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-gradient);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
      background: var(--panel-bg);
      border-radius: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.5);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 95vh;
    }
    
    .header {
      background: #111;
      color: white;
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 4px solid var(--accent);
    }

    .header h1 { font-size: 1.5rem; letter-spacing: 1px; text-transform: uppercase; }
    
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .sidebar {
      width: 320px;
      background: #f0f0f0;
      padding: 20px;
      overflow-y: auto;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .control-group {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    .control-group h3 {
      font-size: 0.9rem;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 12px;
      border-bottom: 2px solid #eee;
      padding-bottom: 5px;
    }
    
    .slider-row { margin-bottom: 15px; }
    .slider-row label { display: flex; justify-content: space-between; margin-bottom: 5px; font-weight: 600; font-size: 0.9rem; }
    input[type="range"] { width: 100%; accent-color: var(--accent); }
    
    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
      margin-bottom: 8px;
    }
    
    .btn:active { transform: scale(0.98); }
    .btn-primary { background: #2f3542; color: white; }
    .btn-accent { background: var(--accent); color: white; }
    
    .assets-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    
    .asset-item {
      aspect-ratio: 1;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.2s;
      padding: 5px;
    }
    
    .asset-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none; /* Let drag event trigger on parent */
    }
    
    .asset-item:hover, .asset-item.selected {
      border-color: var(--accent);
      background: #fff0f2;
    }
    
    .canvas-area {
      flex: 1;
      background: #2a2a2a;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    /* Checkerboard background for transparency context */
    .canvas-bg {
      background-image: 
        linear-gradient(45deg, #1f1f1f 25%, transparent 25%), 
        linear-gradient(-45deg, #1f1f1f 25%, transparent 25%), 
        linear-gradient(45deg, transparent 75%, #1f1f1f 75%), 
        linear-gradient(-45deg, transparent 75%, #1f1f1f 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    canvas {
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Spec_Geo // Lithography Engine</h1>
      <small style="opacity: 0.7">v2.1 Sculptural Build</small>
    </div>
    
    <div class="main">
      <div class="sidebar">
        
        <div class="control-group">
          <h3>Composition</h3>
          <div class="slider-row">
            <label>Cavity Count <span id="val-windows">5</span></label>
            <input type="range" id="windows" min="1" max="8" value="5">
          </div>
          <div class="slider-row">
            <label>Erosion (Roughness) <span id="val-roughness">0.6</span></label>
            <input type="range" id="roughness" min="0.1" max="1.0" step="0.1" value="0.6">
          </div>
          <div class="slider-row">
            <label>Light Source <span id="val-light">270</span>Â°</label>
            <input type="range" id="light" min="0" max="360" value="270">
          </div>
          <button class="btn btn-primary" onclick="generateGlyph()">Generate New Stone</button>
        </div>

        <div class="control-group">
          <h3>Asset Library (Spec_Geo_Assets)</h3>
          <div class="assets-grid" id="assetGrid"></div>
        </div>

        <div class="control-group">
          <button class="btn btn-accent" onclick="exportImage()">Export .PNG</button>
          <button class="btn" onclick="clearAssets()" style="background:#ddd">Clear Placed Items</button>
        </div>
      </div>

      <div class="canvas-area canvas-bg">
        <canvas id="canvas" width="800" height="1000"></canvas>
      </div>
    </div>
  </div>

  <script>
    /* ---------------- CONFIGURATION ---------------- */
    
    // UPDATE THESE NAMES TO MATCH YOUR FILES IN THE FOLDER
    const assetFilenames = [
      'sg_0001.png', 'sg_0104g.png', 'sg_0104c.png', 'sg_0096a.png','sg_0023c.png', 'sg_0047a.png',
      'sg_0191.png', 'sg_0148.png', 'sg_0097b.png','sg_0096h.png', 'sg_0096b.png'
    ];
    
    const ASSET_PATH = 'Spec_Geo_Assets/';

    /* ---------------- ENGINE ---------------- */
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    let state = {
      glyphOutline: [],
      cavities: [], // Renamed from windows
      placedAssets: {}, // Map: cavityID -> ImageObject
      images: {}, // Preloaded images
      noiseCache: []
    };

    let draggedAssetKey = null;

    // --- Noise System ---
    function initNoise() {
      state.noiseCache = new Float32Array(512);
      for(let i=0; i<512; i++) state.noiseCache[i] = Math.random();
    }

    function noise(x, y) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      // Simple value noise
      return state.noiseCache[X + state.noiseCache[Y] * 255 & 255]; 
    }

    // --- Geometry Helpers ---
    function generateBlob(cx, cy, radius, roughness, seedOffset) {
      const points = [];
      const steps = 60; // Higher resolution for smoother stone
      for (let i = 0; i < steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        // Layered noise for "Rocky" feel
        const n1 = noise(Math.cos(theta) * 3 + seedOffset, Math.sin(theta) * 3 + seedOffset);
        const n2 = noise(Math.cos(theta) * 10 + seedOffset, Math.sin(theta) * 10 + seedOffset);
        
        const r = radius * (0.8 + (n1 * 0.3 * roughness) + (n2 * 0.05 * roughness));
        points.push({
          x: cx + Math.cos(theta) * r,
          y: cy + Math.sin(theta) * r
        });
      }
      return points;
    }

    function smoothPoints(points, iterations=2) {
      let current = points;
      for(let k=0; k<iterations; k++) {
        const next = [];
        for (let i = 0; i < current.length; i++) {
          const prev = current[(i - 1 + current.length) % current.length];
          const pt = current[i];
          const nxt = current[(i + 1) % current.length];
          next.push({
            x: (prev.x + pt.x + nxt.x) / 3,
            y: (prev.y + pt.y + nxt.y) / 3
          });
        }
        current = next;
      }
      return current;
    }

    function isInside(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // --- Core Generation Logic ---
    function generateGlyph() {
      initNoise();
      const numCavities = parseInt(document.getElementById('windows').value);
      const roughness = parseFloat(document.getElementById('roughness').value);
      
      state.cavities = [];
      state.placedAssets = {}; // Clear placed assets on regen

      // 1. Generate Master Stone (The Container)
      // We make it slightly smaller than canvas to ensure room for effects
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const masterRadius = Math.min(canvas.width, canvas.height) * 0.45;
      
      let outline = generateBlob(cx, cy, masterRadius, roughness, Math.random() * 100);
      state.glyphOutline = smoothPoints(outline, 3);

      // 2. Carve Cavities (The Sculptural Step)
      let attempts = 0;
      const maxAttempts = 200;
      
      while (state.cavities.length < numCavities && attempts < maxAttempts) {
        attempts++;
        
        // Random position, biased slightly towards center
        const r = Math.random() * (masterRadius * 0.7); 
        const theta = Math.random() * Math.PI * 2;
        const wx = cx + Math.cos(theta) * r;
        const wy = cy + Math.sin(theta) * r;
        
        const wSize = 50 + Math.random() * 80; // Size variation

        // A. Overlap Check (Cavity vs Cavity)
        // We use a large multiplier (1.8) to ensure thick stone walls between cavities
        const overlapsOther = state.cavities.some(c => {
          const dist = Math.hypot(c.x - wx, c.y - wy);
          return dist < (c.size + wSize) * 1.2; 
        });
        
        if (overlapsOther) continue;

        // B. Encapsulation Check (Cavity vs Master Stone)
        // We generate the candidate shape and check if all points are safely inside the master
        let candidateShape = generateBlob(wx, wy, wSize, roughness * 0.8, Math.random()*100);
        candidateShape = smoothPoints(candidateShape, 2);
        
        let fullyInside = true;
        for(let pt of candidateShape) {
            // Check if point is inside master stone
            if(!isInside(pt.x, pt.y, state.glyphOutline)) {
                fullyInside = false;
                break;
            }
            
            // Extra safety: Check distance to master edge (fake SDF)
            // This is computationally expensive so we just trust the radius check mostly,
            // but strict users want NO overlap.
            // Simplified: if center + radius is > master boundaries roughly
        }

        if (fullyInside) {
          state.cavities.push({
            id: Date.now() + state.cavities.length,
            x: wx,
            y: wy,
            size: wSize,
            shape: candidateShape
          });
        }
      }

      render();
    }

    // --- Rendering Pipeline ---
    function render() {
      const lightVal = parseInt(document.getElementById('light').value);
      const lightAngle = (lightVal * Math.PI) / 180;
      
      // Clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (state.glyphOutline.length === 0) return;

      // 1. Draw Master Stone Body
      ctx.save();
      ctx.beginPath();
      const pts = state.glyphOutline;
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      
      // Create clip mask for texture
      ctx.clip();

      // Stone Base Color
      const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      grad.addColorStop(0, '#555');
      grad.addColorStop(1, '#333');
      ctx.fillStyle = grad;
      ctx.fill(); // Fill the clipped area

      // 2. Procedural Texture (The "Rough Rocky" Look)
      // We process pixels only inside the bounding box of the stone for performance
      const imageData = ctx.getImageData(0,0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // Optimization: stride of 2 for performance, linear interpolation for look
      for (let y = 0; y < canvas.height; y+=2) {
        for (let x = 0; x < canvas.width; x+=2) {
          // Quick check: only process roughly inside
          const idx = (y * canvas.width + x) * 4;
          // Check alpha to see if we are inside the clipped stone
          // Note: getImageData captures the fill we just did. 
          if (data[idx+3] < 100) continue; 

          // Height map generation
          // Low freq for shape, High freq for "grain"
          const nx = x * 0.005; 
          const ny = y * 0.005;
          const h1 = noise(nx, ny);
          const h2 = noise(nx*10, ny*10) * 0.1; // Grit
          
          // Normal map calculation
          // We cheat and look at neighbor noise
          const neighbors = noise(nx + 0.01, ny);
          const slopeX = (h1 - neighbors) * 40; 
          const slopeY = (h1 - noise(nx, ny + 0.01)) * 40;

          // Lighting math
          // Rotate normal based on slope
          const dot = (Math.cos(lightAngle) * slopeX + Math.sin(lightAngle) * slopeY);
          
          const highlight = Math.max(0, dot);
          const shadow = Math.max(0, -dot);
          
          let color = data[idx]; // Base gray
          color += highlight * 60;
          color -= shadow * 80;
          
          // Noise texture
          color += (Math.random() - 0.5) * 15;

          data[idx] = data[idx+1] = data[idx+2] = Math.max(0, Math.min(255, color));
          data[idx+3] = 255;
          
          // Fill the 2x2 block
          const idx2 = idx + 4;
          const idx3 = idx + canvas.width * 4;
          const idx4 = idx3 + 4;
          // (Omitting full 2x2 write for brevity, just keeping sparse or accepting aliasing for style)
        }
      }
      ctx.putImageData(imageData, 0, 0);
      ctx.restore();

      // 3. Draw Cavities (Shadows & Depth)
      state.cavities.forEach(cavity => {
        // Drop Shadow (Ambient Occlusion inside hole)
        ctx.save();
        
        // Inner Shadow (Simulating depth)
        ctx.translate(Math.cos(lightAngle)*2, Math.sin(lightAngle)*2);
        
        ctx.beginPath();
        ctx.moveTo(cavity.shape[0].x, cavity.shape[0].y);
        for(let p of cavity.shape) ctx.lineTo(p.x, p.y);
        ctx.closePath();
        
        ctx.fillStyle = '#0a0a0a'; // Deep black hole
        ctx.fill();

        // Inner Bevel Highlight (Rim light on the opposite side of light source)
        ctx.strokeStyle = `rgba(255,255,255,0.2)`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();

        // 4. Render Asset inside Cavity
        if (state.placedAssets[cavity.id]) {
          const imgKey = state.placedAssets[cavity.id];
          if (state.images[imgKey]) {
            ctx.save();
            
            // Clip to cavity shape
            ctx.beginPath();
            ctx.moveTo(cavity.shape[0].x, cavity.shape[0].y);
            for(let p of cavity.shape) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            ctx.clip();
            
            // Draw Image centered
            const img = state.images[imgKey];
            const scale = (cavity.size * 2) / Math.max(img.width, img.height) * 0.8; // 80% fit
            const drawW = img.width * scale;
            const drawH = img.height * scale;
            
            ctx.drawImage(img, 
              cavity.x - drawW/2, 
              cavity.y - drawH/2, 
              drawW, drawH
            );
            
            // Inner Shadow Overlay to make asset look "inside"
            ctx.shadowColor = "black";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 4;
            ctx.stroke();
            
            ctx.restore();
          }
        }
      });
      
      // 5. Final Edge Rim Light (Outer Stone)
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(state.glyphOutline[0].x, state.glyphOutline[0].y);
      for(let p of state.glyphOutline) ctx.lineTo(p.x, p.y);
      ctx.closePath();
      
      // Top edge highlight based on light angle
      ctx.shadowColor = 'rgba(255,255,255,0.4)';
      ctx.shadowBlur = 2;
      ctx.shadowOffsetX = -Math.cos(lightAngle) * 2;
      ctx.shadowOffsetY = -Math.sin(lightAngle) * 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.stroke();
      ctx.restore();
    }

    // --- Interaction ---
    function loadAssets() {
      const grid = document.getElementById('assetGrid');
      grid.innerHTML = '';
      
      assetFilenames.forEach(filename => {
        // Preload Image object
        const img = new Image();
        img.src = ASSET_PATH + filename;
        img.onload = () => {
          state.images[filename] = img;
        };

        // Create UI Element
        const div = document.createElement('div');
        div.className = 'asset-item';
        div.draggable = true;
        
        // Thumbnail
        const thumb = document.createElement('img');
        thumb.src = ASSET_PATH + filename;
        div.appendChild(thumb);
        
        // Drag Events
        div.addEventListener('dragstart', (e) => {
          draggedAssetKey = filename;
          e.dataTransfer.setData('text/plain', filename);
        });
        
        // Click Events (Mobile/Tablet)
        div.addEventListener('click', () => {
          document.querySelectorAll('.asset-item').forEach(d => d.classList.remove('selected'));
          div.classList.add('selected');
          draggedAssetKey = filename;
        });

        grid.appendChild(div);
      });
    }

    // Canvas Drop Handling
    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      handleInteraction(e.clientX, e.clientY);
    });

    canvas.addEventListener('click', e => {
      if(draggedAssetKey) handleInteraction(e.clientX, e.clientY);
    });

    function handleInteraction(clientX, clientY) {
      if(!draggedAssetKey) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      
      // Find cavity under mouse
      const target = state.cavities.find(c => isInside(x, y, c.shape));
      
      if(target) {
        state.placedAssets[target.id] = draggedAssetKey;
        render();
      }
    }

    function clearAssets() {
      state.placedAssets = {};
      render();
    }

    function exportImage() {
      const link = document.createElement('a');
      link.download = `Spec_Geo_Scan_${Date.now()}.png`;
      link.href = canvas.toDataURL();
      link.click();
    }

    // --- Init ---
    document.querySelectorAll('input').forEach(el => {
      el.addEventListener('input', (e) => {
        // Update label text
        const labelSpan = document.getElementById('val-' + e.target.id);
        if(labelSpan) labelSpan.textContent = e.target.value;
        
        // If it's light, just re-render. If it's geometry, regen.
        if(e.target.id === 'light') render();
        else generateGlyph();
      })
    });

    loadAssets();
    setTimeout(generateGlyph, 100); // Slight delay to ensure assets start loading
  </script>
</body>
</html>

