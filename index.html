<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digital Talisman Maker v4</title>
  <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
      --panel-bg: rgba(255, 255, 255, 0.95);
      --accent: #5d6d7e; 
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: var(--bg-gradient);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
      background: var(--panel-bg);
      border-radius: 12px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.5);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 95vh;
    }
    
    .header {
      background: #fff;
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #eee;
    }

    .header h1 { font-size: 1.2rem; letter-spacing: 1px; text-transform: uppercase; color: #333; }
    
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .sidebar {
      width: 320px;
      background: #f9f9f9;
      padding: 20px;
      overflow-y: auto;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .control-group {
      background: white;
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #eee;
    }
    
    .control-group h3 {
      font-size: 0.8rem;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 15px;
      letter-spacing: 0.5px;
    }

    .text-input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 0.9rem;
    }
    
    .slider-row { margin-bottom: 15px; }
    .slider-row label { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; color: #555;}
    input[type="range"] { width: 100%; accent-color: var(--accent); }
    
    .btn {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 8px;
      text-transform: uppercase;
      transition: all 0.2s;
    }
    
    .btn-primary { background: #333; color: white; }
    .btn-primary:hover { background: #000; }
    .btn-secondary { background: #e0e0e0; color: #333; }
    
    .assets-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    
    .asset-item {
      aspect-ratio: 1;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 5px;
    }
    .asset-item:hover { border-color: #333; }
    .asset-item img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
    
    .canvas-area {
      flex: 1;
      background: #e8e8e8;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    canvas {
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      background: transparent;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Talisman // Lithos Engine</h1>
    </div>
    
    <div class="main">
      <div class="sidebar">
        
        <div class="control-group">
          <h3>Intention</h3>
          <input type="text" id="intentionInput" class="text-input" placeholder="Enter intention..." maxlength="40">
        </div>

        <div class="control-group">
          <h3>Stone Formation</h3>
          <div class="slider-row">
            <label>Cavities <span id="val-windows">4</span></label>
            <input type="range" id="windows" min="1" max="6" value="4">
          </div>
          <div class="slider-row">
            <label>Erosion <span id="val-roughness">0.6</span></label>
            <input type="range" id="roughness" min="0.1" max="1.0" step="0.1" value="0.6">
          </div>
          <div class="slider-row">
            <label>Light Angle <span id="val-light">135</span>Â°</label>
            <input type="range" id="light" min="0" max="360" value="135">
          </div>
          <button class="btn btn-primary" onclick="generateTalisman()">Forge Stone</button>
        </div>

        <div class="control-group">
          <h3>Assets</h3>
          <div class="assets-grid" id="assetGrid"></div>
        </div>

        <div class="control-group">
          <button class="btn btn-secondary" onclick="exportImage()">Download .PNG</button>
          <button class="btn btn-secondary" onclick="clearAssets()">Clear Items</button>
        </div>
      </div>

      <div class="canvas-area">
        <canvas id="canvas" width="700" height="1000"></canvas>
      </div>
    </div>
  </div>

  <script>
    /* ---------------- CONFIGURATION ---------------- */
    
    // ASSETS
    const assetFilenames = ['sg_0001.png', 'sg_0008b.png', 'sg_0023c.png', 'sg_0047a.png', 'sg_0055d.png', 'sg_0056b.png','sg_0058d.png', 'sg_0063a.png', 'sg_0067.png', 'sg_0070.png','sg_0072.png', 'sg_0078a.png', 'sg_0078f.png', 'sg_0080b.png', 'sg_0080c.png', 'sg_0085a.png', 'sg_0085b.png', 'sg_0086a.png','sg_0096a.png', 'sg_0096b.png', 'sg_0096h.png', 'sg_0097b.png','sg_0104c.png', 'sg_0104g.png', 'sg_0148.png', 'sg_0191.png'];
    const ASSET_PATH = 'Spec_Geo_Assets/';

    // TEXTURES
    // Assumes files are named texture01.png, texture02.png ... texture10.png
    const TEXTURE_COUNT = 10;
    const TEXTURE_PATH = 'Textures/';

    /* ---------------- STATE ---------------- */
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    let state = {
      talismanOutline: [],
      cavities: [], 
      placedAssets: {}, 
      images: {}, // Loaded Sigils
      textures: [], // Loaded Textures
      activeTextures: [], // The 2 textures chosen for current generation
      noiseCache: [],
      intentionText: ""
    };

    let draggedAssetKey = null;

    // --- Noise System ---
    function initNoise() {
      state.noiseCache = new Float32Array(1024);
      for(let i=0; i<1024; i++) state.noiseCache[i] = Math.random();
    }
    function noise(x, y) {
      const X = Math.floor(Math.abs(x)) & 1023;
      const Y = Math.floor(Math.abs(y)) & 1023;
      return state.noiseCache[X + state.noiseCache[Y] * 1023 & 1023]; 
    }

    // --- Generation Logic ---

    // 1. Phone Shape (Scaled down to fit screen)
    function generateTalismanShape(width, height, roughness, seedOffset) {
        const points = [];
        const steps = 150; 
        const cx = canvas.width / 2;
        const cy = canvas.height / 2 - 50; // Shifted up slightly to make room for text
        
        for (let i = 0; i < steps; i++) {
            const t = i / steps;
            const angle = t * Math.PI * 2;
            
            // Box shape logic
            const sx = Math.cos(angle) * width/2;
            const sy = Math.sin(angle) * height/2;
            
            // Round Rect approximation
            let px = cx + Math.max(-width/2, Math.min(width/2, sx * 1.3));
            let py = cy + Math.max(-height/2, Math.min(height/2, sy * 1.3));

            // Noise
            const n1 = noise(px * 0.005 + seedOffset, py * 0.005 + seedOffset) - 0.5;
            const erosion = n1 * 80 * roughness;
            
            // Vector from center
            const dx = px - cx;
            const dy = py - cy;
            const dist = Math.hypot(dx, dy);
            
            points.push({
                x: px + (dx/dist) * erosion,
                y: py + (dy/dist) * erosion
            });
        }
        return smoothPoints(points, 3);
    }

    // 2. Cavity Logic (Added Oval/Irregular variety)
    function generateCavityShape(cx, cy, avgSize, roughness, seedOffset) {
      const points = [];
      const steps = 50; 
      
      // Determine type: 0 = Rocky/Spiky, 1 = Ovaloid/Smooth
      const isOval = Math.random() > 0.4;
      // If oval, determine aspect ratio stretch
      const stretchX = isOval ? 0.7 + Math.random() * 0.6 : 1;
      const stretchY = isOval ? 0.7 + Math.random() * 0.6 : 1;
      const rotation = Math.random() * Math.PI;

      for (let i = 0; i < steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        
        // Base shape
        let rx = Math.cos(theta) * avgSize * stretchX;
        let ry = Math.sin(theta) * avgSize * stretchY;

        // Rotate oval
        if(isOval) {
            const rotX = rx * Math.cos(rotation) - ry * Math.sin(rotation);
            const rotY = rx * Math.sin(rotation) + ry * Math.cos(rotation);
            rx = rotX; ry = rotY;
        }

        // Apply noise
        // Less noise for ovals, more for rocky stars
        const noiseFactor = isOval ? 0.2 : 0.8; 
        const n = noise(Math.cos(theta)*3 + seedOffset, Math.sin(theta)*3 + seedOffset);
        
        const distortion = 1 + (n - 0.5) * noiseFactor * roughness;

        points.push({
          x: cx + rx * distortion,
          y: cy + ry * distortion
        });
      }
      return smoothPoints(points, isOval ? 2 : 1);
    }

    function smoothPoints(points, iterations=1) {
      let current = points;
      for(let k=0; k<iterations; k++) {
        const next = [];
        for (let i = 0; i < current.length; i++) {
          const prev = current[(i - 1 + current.length) % current.length];
          const pt = current[i];
          const nxt = current[(i + 1) % current.length];
          next.push({ x: (prev.x + pt.x + nxt.x) / 3, y: (prev.y + pt.y + nxt.y) / 3 });
        }
        current = next;
      }
      return current;
    }

    function isInside(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function generateTalisman() {
      initNoise();
      const numCavities = parseInt(document.getElementById('windows').value);
      const roughness = parseFloat(document.getElementById('roughness').value);
      
      state.cavities = [];
      state.placedAssets = {}; 

      // Pick 2 random textures for this stone to layer them
      if(state.textures.length > 0) {
        const t1 = Math.floor(Math.random() * state.textures.length);
        let t2 = Math.floor(Math.random() * state.textures.length);
        state.activeTextures = [state.textures[t1], state.textures[t2]];
      }

      // Generate Base Shape
      // Reduced size so it doesn't touch edges (Width * 0.45 instead of 0.55)
      const phoneWidth = canvas.width * 0.45; 
      const phoneHeight = canvas.height * 0.65; 
      
      state.talismanOutline = generateTalismanShape(phoneWidth, phoneHeight, roughness, Math.random() * 100);

      // Carve Cavities
      let attempts = 0;
      // Define safe zone
      const bounds = {
          minX: canvas.width/2 - phoneWidth*0.4,
          maxX: canvas.width/2 + phoneWidth*0.4,
          minY: canvas.height/2 - 50 - phoneHeight*0.4,
          maxY: canvas.height/2 - 50 + phoneHeight*0.4
      };

      while (state.cavities.length < numCavities && attempts < 500) {
        attempts++;
        const wx = bounds.minX + Math.random() * (bounds.maxX - bounds.minX);
        const wy = bounds.minY + Math.random() * (bounds.maxY - bounds.minY);
        const wSize = 40 + Math.random() * 60;

        if (state.cavities.some(c => Math.hypot(c.x - wx, c.y - wy) < (c.size + wSize) * 1.2)) continue;

        let shape = generateCavityShape(wx, wy, wSize, roughness, Math.random()*500);
        
        // Strict containment check
        let fullyInside = true;
        for(let pt of shape) {
            if(!isInside(pt.x, pt.y, state.talismanOutline)) { fullyInside = false; break; }
        }

        if (fullyInside) {
          state.cavities.push({ id: Date.now() + attempts, x: wx, y: wy, size: wSize, shape: shape });
        }
      }
      render();
    }

    function render() {
      const lightVal = parseInt(document.getElementById('light').value);
      const lightAngle = (lightVal * Math.PI) / 180;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (state.talismanOutline.length === 0) return;

      // 1. Draw Master Stone Mask
      ctx.save();
      ctx.beginPath();
      const pts = state.talismanOutline;
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      ctx.clip(); // Restrict everything to stone shape

      // 2. Base Color
      ctx.fillStyle = '#666'; 
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // 3. Apply Textures (The new Engine)
      if(state.activeTextures.length > 0 && state.activeTextures[0]) {
        // Texture 1: Multiply (Darkens and adds grit)
        ctx.globalCompositeOperation = 'multiply';
        // Draw slightly larger to cover wobbles
        ctx.drawImage(state.activeTextures[0], 0, 0, canvas.width, canvas.height);
        
        // Texture 2: Soft Light or Overlay (Adds variation/detail)
        if(state.activeTextures[1]) {
            ctx.globalCompositeOperation = 'soft-light';
            ctx.globalAlpha = 0.7;
            // Maybe flip this one for randomness
            ctx.save();
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(state.activeTextures[1], 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
      }
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = 'source-over';

      // 4. Procedural Lighting Overlay (Gradient)
      const grad = ctx.createLinearGradient(0,0,canvas.width, canvas.height);
      grad.addColorStop(0, 'rgba(255,255,255,0.2)'); // Top left highlight
      grad.addColorStop(0.5, 'rgba(0,0,0,0)'); 
      grad.addColorStop(1, 'rgba(0,0,0,0.4)'); // Bottom right shadow
      ctx.fillStyle = grad;
      ctx.fill();

      // 5. Inner Shadow / Bevel for the main stone
      // We fake 3D depth by drawing a shadow on one side of the clip
      ctx.restore(); // Undo clip
      
      // Draw shadow under stone
      ctx.save();
      ctx.translate(10, 20);
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.filter = 'blur(15px)';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.fill();
      ctx.restore();

      // Draw Cavities
      state.cavities.forEach(cavity => {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cavity.shape[0].x, cavity.shape[0].y);
        for(let p of cavity.shape) ctx.lineTo(p.x, p.y);
        ctx.closePath();
        
        // Fill Cavity (Dark background)
        ctx.fillStyle = '#111';
        ctx.fill();
        
        // Inner Shadows (Depth)
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0; 
        ctx.shadowOffsetY = 0;
        ctx.strokeStyle = 'rgba(0,0,0,0.8)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // Highlight Rim (Opposite to light)
        ctx.shadowColor = 'transparent';
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        // Offset stroke slightly to look like a rim
        ctx.stroke();

        ctx.restore();

        // Draw Asset
        if (state.placedAssets[cavity.id] && state.images[state.placedAssets[cavity.id]]) {
            const img = state.images[state.placedAssets[cavity.id]];
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(cavity.shape[0].x, cavity.shape[0].y);
            for(let p of cavity.shape) ctx.lineTo(p.x, p.y);
            ctx.clip();
            
            const scale = (cavity.size * 2) / Math.max(img.width, img.height) * 0.75;
            const drawW = img.width * scale;
            const drawH = img.height * scale;
            
            ctx.globalAlpha = 0.9;
            ctx.drawImage(img, cavity.x - drawW/2, cavity.y - drawH/2, drawW, drawH);
            
            // Texture overlay on asset to make it look painted on stone
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(cavity.x - drawW/2, cavity.y - drawH/2, drawW, drawH);
            
            ctx.restore();
        }
      });

      // 6. Draw Text (Floating below)
      if(state.intentionText) {
          ctx.font = '14px Helvetica, Arial, sans-serif';
          ctx.fillStyle = '#555'; // Subtle gray
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.letterSpacing = '1px';
          // Position relative to bottom of canvas
          ctx.fillText(state.intentionText.toUpperCase(), canvas.width/2, canvas.height - 80);
      }
    }

    // --- Loading & Init ---
    function loadResources() {
      // Load Sigils
      const grid = document.getElementById('assetGrid');
      grid.innerHTML = '';
      assetFilenames.forEach(filename => {
        const img = new Image();
        img.src = ASSET_PATH + filename;
        img.onload = () => { state.images[filename] = img; };
        
        const div = document.createElement('div');
        div.className = 'asset-item';
        div.draggable = true;
        const thumb = document.createElement('img');
        thumb.src = ASSET_PATH + filename;
        div.appendChild(thumb);
        div.addEventListener('dragstart', (e) => {
          draggedAssetKey = filename;
          e.dataTransfer.setData('text/plain', filename);
        });
        grid.appendChild(div);
      });

      // Load Textures
      let texturesLoaded = 0;
      for(let i=1; i<=TEXTURE_COUNT; i++) {
        // Formats number to 01, 02, etc.
        const num = i.toString().padStart(2, '0');
        const img = new Image();
        img.src = `${TEXTURE_PATH}texture${num}.png`;
        img.onload = () => {
            state.textures.push(img);
            texturesLoaded++;
            // If we have at least 2 textures, we can start generating valid stones
            if(texturesLoaded === 2) generateTalisman();
        };
        // Error handling just in case file missing
        img.onerror = () => console.log(`Texture ${num} not found.`);
      }
    }

    // Interaction
    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const target = state.cavities.find(c => isInside(x, y, c.shape));
      if(target) {
        state.placedAssets[target.id] = draggedAssetKey;
        render();
      }
    });

    document.getElementById('intentionInput').addEventListener('input', (e) => {
        state.intentionText = e.target.value;
        render();
    });

    document.querySelectorAll('input[type=range]').forEach(el => {
      el.addEventListener('input', (e) => {
        document.getElementById('val-' + e.target.id).textContent = e.target.value;
        if(e.target.id === 'light') render(); else generateTalisman();
      })
    });

    function clearAssets() { state.placedAssets = {}; render(); }
    function exportImage() {
      const link = document.createElement('a');
      link.download = `Talisman.png`;
      link.href = canvas.toDataURL();
      link.click();
    }

    loadResources();
    // Fallback generation if textures take too long or fail
    setTimeout(() => { if(state.talismanOutline.length === 0) generateTalisman(); }, 1000);
  </script>
</body>
</html>
