<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Talisman Agency</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Stylish&display=swap" rel="stylesheet">

  <style>
    :root {
      /* [NOTE] GLOBAL COLORS */
      --bg-color: #000000;
      
      /* [NOTE] SIDEBAR PALETTE */
      --sidebar-bg: #111111;       
      --sidebar-surface: #1a1a1a;  
      --text-main: #cccccc;        
      --text-muted: #777777;       
      --border-color: #333333;     
      --highlight: #8e44ad;
      --accent: #555; 
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      font-family: 'Stylish', sans-serif;
      background: var(--bg-color);
      height: 100vh;
      overflow: hidden; 
      padding: 0;
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      cursor: none; 
    }
    
    /* --- CUSTOM CURSOR GLOW --- */
    #cursor-glow {
      position: fixed;
      top: 0; left: 0; width: 60px; height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(142, 68, 173, 0.6) 0%, rgba(142, 68, 173, 0) 70%);
      pointer-events: none; z-index: 9999;
      transform: translate(-50%, -50%);
      transition: opacity 0.2s ease;
      mix-blend-mode: screen; 
    }
    body:hover #cursor-glow { opacity: 1; }
    
    .header {
      background: transparent; 
      padding: 15px 10px;
      display: flex; 
      justify-content: center; 
      align-items: center;
      border-bottom: none;
      flex-shrink: 0; z-index: 10; color: #B6B5B5
    }
    .header h1 { font-size: 1.5rem; letter-spacing: 1px; text-transform: uppercase; font-weight: 400;}
    
    .main { display: flex; flex: 1; overflow: hidden; position: relative; flex-direction: row; }
    
    /* --- SIDEBAR --- */
    .sidebar {
      width: 360px;
      background: var(--sidebar-bg);
      color: var(--text-main);
      
      margin: 10px 0 20px 20px;
      height: calc(100% - 30px);
      
      border-radius: 45px 25px 55px 30px / 30px 55px 25px 45px;
      transform: rotate(-0.5deg);
      
      /* [NOTE] FUZZINESS SETTINGS */
      box-shadow: 
        0 0 10px 1px var(--sidebar-bg), 
        0 20px 50px rgba(0,0,0,1); 
      
      border: 1px solid #222; 
      
      animation: morphBorder 6s ease-in-out infinite alternate;
      
      /* [NOTE] WOBBLY EDGE FILTER APPLIED HERE */
      filter: url(#wobbly); 
      
      overflow: hidden; 
      display: flex; flex-direction: column; flex-shrink: 0; z-index: 3; order: 1;
      position: relative;
    }

    @keyframes morphBorder {
      0% { 
        border-radius: 45px 25px 55px 30px / 30px 55px 25px 45px;
        transform: rotate(-0.5deg);
      }
      100% { 
        border-radius: 25px 55px 30px 45px / 55px 30px 45px 25px;
        transform: rotate(0deg); 
      }
    }
    
    .sidebar-content { flex: 1; overflow-y: auto; cursor: default; padding-right: 0; }

    .sidebar-footer {
        font-family: "Gill Sans", "Gill Sans MT", "Myriad Pro", "DejaVu Sans Condensed", Helvetica, Arial, "sans-serif";
        padding: 20px;
        font-size: 0.75rem;
        color: var(--text-muted);
        border-top: 1px solid var(--border-color);
        line-height: 1.2;
        background: var(--sidebar-bg);
    }

    .accordion-item { border-bottom: 1px solid var(--border-color); background: var(--sidebar-surface); }
    
    .accordion-header {
      width: 100%; text-align: left; 
      background: var(--sidebar-surface);
      padding: 20px;
      border: none; outline: none; cursor: pointer;
      font-family: 'Stylish', sans-serif;
      font-size: 1.1rem; 
      font-weight: 300; letter-spacing: 1px; 
      color: #eee;
      display: flex; justify-content: space-between; align-items: center;
      text-transform: uppercase; min-height: 60px; 
    }
    .accordion-header:hover { background: #252525; }
    .accordion-header::after { content: '+'; font-size: 1.2rem; font-weight: 300; color: #666; }
    .accordion-item.active .accordion-header::after { content: '-'; }
    
    .accordion-body { 
        max-height: 0; overflow: hidden; 
        transition: max-height 0.4s cubic-bezier(0.25, 1, 0.5, 1); 
        background: var(--sidebar-bg);
    }
    .accordion-inner { padding: 20px; border-top: 1px solid var(--border-color); }
    .accordion-item.disabled { pointer-events: none; opacity: 0.5; }

    /* --- FORM ELEMENTS --- */
    .text-input { 
        width: 100%; padding: 12px; 
        background: #000;
        border: 1px solid #444; 
        color: #fff;
        border-radius: 6px; 
        font-family: 'Stylish', sans-serif; font-size: 1.1rem; 
    }
    .text-input:focus { outline: none; border-color: var(--highlight); }

    .slider-row { margin-bottom: 15px; }
    .slider-row label { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 1rem; color: #999;}
    input[type="range"] { width: 100%; accent-color: var(--highlight); height: 6px; cursor: pointer; background: #333; }
    
    .btn { 
        width: 100%; padding: 12px; border: none; border-radius: 6px; 
        font-family: 'Stylish', sans-serif; font-size: 1.1rem; 
        cursor: pointer; text-transform: uppercase; margin-bottom: 10px; 
    }
    .btn-primary { background: #eee; color: #000; margin-top: 10px; } 
    .btn-primary:hover { background: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.3); }
    
    .btn-secondary { background: #333; color: #ccc; border: 1px solid #444; }
    .btn-secondary:hover { background: #444; color: #fff; }
    
    .upload-btn-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; margin-bottom: 15px; }
    .upload-btn-wrapper input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; height: 100%; }

    .assets-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    
    .asset-item { 
        aspect-ratio: 1; 
        background: #222; 
        border: 1px solid #444; 
        border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 4px; position: relative; 
    }
    .asset-item img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; filter: invert(0.1); } 
    .asset-item.selected { border-color: var(--highlight); background: #333; transform: scale(1.05); }
    
    /* --- CANVAS --- */
    .canvas-area {
      flex: 1; background: #000000; display: flex; align-items: center; justify-content: center;
      position: relative; overflow: hidden; order: 2; cursor: none; 
    }
    canvas { height: 96%; width: auto; max-width: 98%; object-fit: contain; }

    /* --- MOBILE --- */
    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .header { position: sticky; top: 0; z-index: 1000; background: rgba(0, 0, 0, 0.9); border-bottom: 1px solid #333; }
      .canvas-area { height: 50vh; flex: none; order: 1; padding: 10px; cursor: auto;}
      
      .sidebar { 
          width: 100%; flex: 1; margin: 0; 
          border-radius: 0; 
          height: auto; border-top: 1px solid #333; 
          order: 2; animation: none; transform: none; 
          box-shadow: none;
          filter: none; /* Disable wobble on mobile for performance */
      }
      
      .assets-grid { grid-template-columns: repeat(5, 1fr); }
      #cursor-glow { display: none; } 
    }
  </style>
</head>
<body>

  <svg style="position: absolute; width: 0; height: 0; pointer-events: none;">
    <filter id="wobbly">
      <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="2" result="warp" />
      <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="3" in="SourceGraphic" in2="warp" />
    </filter>
  </svg>

  <div id="cursor-glow"></div>

  <div class="header">
    <h1>*:･ﾟ✧*:･ﾟ Talisman for Devices <small>v. I.0</small>  *:･ﾟ✧*:･ﾟ</h1>
  </div>
  
  <div class="main">
    <div class="sidebar" id="sidebar">
      <div class="sidebar-content">
        
        <div class="accordion-item" id="acc-intention">
          <button class="accordion-header" onclick="toggleAccordion('acc-intention')">I. Intention ˚ · • . ° .</button>
          <div class="accordion-body"><div class="accordion-inner">
             <input type="text" id="intentionInput" class="text-input" placeholder="Type intention..." maxlength="40">
          </div></div>
        </div>

        <div class="accordion-item" id="acc-formation">
          <button class="accordion-header" onclick="toggleAccordion('acc-formation')">II. Formation *. * ·:･ﾟ</button>
          <div class="accordion-body"><div class="accordion-inner">
              <div class="slider-row">
                <label>Cavities <span id="val-windows">4</span></label>
                <input type="range" id="windows" min="1" max="8" value="4" oninput="updateVal('windows', this.value); generateFullTalisman()">
              </div>
              <div class="slider-row">
                <label>Erosion <span id="val-roughness">0.0</span></label>
                <input type="range" id="roughness" min="0.0" max="1.0" step="0.01" value="0.0" oninput="updateVal('roughness', this.value); updateContourOnly()">
              </div>
              <button class="btn btn-primary" onclick="generateFullTalisman()">Reform Talisman</button>
          </div></div>
        </div>

        <div class="accordion-item" id="acc-selection">
          <button class="accordion-header" onclick="toggleAccordion('acc-selection')">III. Selection *:･ﾟ✧*:･ﾟ</button>
          <div class="accordion-body"><div class="accordion-inner">
              <div class="upload-btn-wrapper">
                <button class="btn btn-secondary">+ Upload Custom Sigil</button>
                <input type="file" id="fileUpload" accept="image/*" onchange="handleFileUpload(event)" />
              </div>
              <div class="assets-grid" id="assetGrid"></div>
          </div></div>
        </div>

        <div class="accordion-item disabled" id="acc-calibration">
          <button class="accordion-header" onclick="toggleAccordion('acc-calibration')">IV. Calibration</button>
          <div class="accordion-body"><div class="accordion-inner">
              <div class="slider-row"><label>Rotate</label><input type="range" id="sigilRot" min="-180" max="180" value="0"></div>
              <div class="slider-row"><label>Scale</label><input type="range" id="sigilScale" min="0.2" max="3.0" step="0.1" value="1.0"></div>
          </div></div>
        </div>

        <div class="accordion-item" id="acc-exportation">
          <button class="accordion-header" onclick="toggleAccordion('acc-exportation')">V. Exportation︒⚬∙︓·⠄</button>
          <div class="accordion-body"><div class="accordion-inner">
              <button class="btn btn-secondary" onclick="exportImage()">Download</button>
              <button class="btn btn-secondary" onclick="clearAssets()" style="background:transparent; border:1px solid #444; color: #888;">Clear Sigils</button>
          </div></div>
        </div>
      </div>
      
      <div class="sidebar-footer">
          Spirits of zero and one; touch the command key of the unseen to manifest fortune and desire through this digital talisman. Ever the Ordinal Solid guides direction and form. <br> <p style="text-align: right;">JULMstudios 2026</p> 
      </div>
    </div>

    <div class="canvas-area">
      <canvas id="canvas" width="900" height="1500"></canvas>
    </div>
  </div>

  <script>
    // --- CONFIGURATION ---
    
    // 1. TEXTURES
    const TEXTURE_FILENAMES = [
        'texture01.png', 'texture02.png', 'texture03.png', 'texture04.png',
        'texture05.png', 'texture06.png', 'texture07.png', 'texture08.png',
        'texture09.png', 'texture10.png','texture11.png', 'texture12.png', 'texture13.png', 'texture14.png',
        'texture15.png', 'texture16.png', 'texture17.png', 'texture18.png',
        'texture19.png', 'texture20.png','texture21.png', 'texture22.png', 'texture23.png', 'texture24.png',
        'texture25.png', 'texture26.png'
    ];

    // 2. SIGILS
    const SIGIL_FILENAMES = [
        'sg_0001.png', 'sg_0008b.png', 'sg_0023c.png', 'sg_0047a.png', 'sg_0055d.png', 'sg_0056b.png','sg_0058d.png', 'sg_0063a.png', 'sg_0067.png', 'sg_0070.png','sg_0072.png', 'sg_0078a.png', 'sg_0078f.png', 'sg_0080b.png', 'sg_0080c.png', 'sg_0085a.png', 'sg_0085b.png', 'sg_0086a.png','sg_0096a.png', 'sg_0096b.png', 'sg_0096h.png', 'sg_0097b.png','sg_0104c.png', 'sg_0104g.png', 'sg_0148.png', 'sg_0191.png'
    ];
    
    const TEXTURES_FOLDER = 'Textures/';
    const ASSETS_FOLDER = 'Spec_Geo_Assets/';

    // --- SYSTEM ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    const BLEND_MODES = ['multiply', 'overlay', 'soft-light', 'hard-light', 'screen', 'darken', 'color-burn', 'exclusion'];

    let state = {
      talismanOutline: [], cavities: [], placedAssets: {}, 
      images: {}, 
      loadedTextures: [], 
      activeTextureStack: [], 
      intentionText: "", selectedAssetKey: null, activeCavityId: null, contourSeed: 0
    };

    // --- CURSOR ---
    const cursorGlow = document.getElementById('cursor-glow');
    document.addEventListener('mousemove', (e) => {
      cursorGlow.style.left = e.clientX + 'px'; cursorGlow.style.top = e.clientY + 'px';
    });

    // --- UTILS ---
    function toggleAccordion(id) {
      const item = document.getElementById(id);
      if(item.classList.contains('disabled')) return;
      const isActive = item.classList.contains('active');
      if(!isActive) {
          document.querySelectorAll('.accordion-item').forEach(el => {
              el.classList.remove('active'); el.querySelector('.accordion-body').style.maxHeight = null;
          });
          item.classList.add('active');
          const body = item.querySelector('.accordion-body');
          body.style.maxHeight = body.scrollHeight + "px";
      } else {
          item.classList.remove('active');
          item.querySelector('.accordion-body').style.maxHeight = null;
      }
    }
    
    function updateVal(id, val) { document.getElementById('val-'+id).textContent = val; }

    function smoothPoints(points, iterations=1) {
      let current = points;
      for(let k=0; k<iterations; k++) {
        const next = [];
        for (let i = 0; i < current.length; i++) {
          const prev = current[(i - 1 + current.length) % current.length];
          const pt = current[i];
          const nxt = current[(i + 1) % current.length];
          next.push({ x: (prev.x + pt.x + nxt.x) / 3, y: (prev.y + pt.y + nxt.y) / 3 });
        }
        current = next;
      }
      return current;
    }

    function isInside(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    
    function getBoundingBox(points) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        points.forEach(p => {
            if(p.x < minX) minX = p.x; if(p.y < minY) minY = p.y;
            if(p.x > maxX) maxX = p.x; if(p.y > maxY) maxY = p.y;
        });
        return { width: maxX - minX, height: maxY - minY, cx: minX + (maxX - minX)/2, cy: minY + (maxY - minY)/2 };
    }

    // --- GENERATION ---
    function generateCavityShape(cx, cy, avgSize) {
      const points = []; const steps = 40; 
      const stretch = 0.7 + Math.random() * 0.5;
      for (let i = 0; i < steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        const r = avgSize * (0.8 + Math.random() * 0.4);
        points.push({ x: cx + Math.cos(theta) * r, y: cy + Math.sin(theta) * r * stretch });
      }
      return smoothPoints(points, 2);
    }

    function updateContourOnly() {
        const t = parseFloat(document.getElementById('roughness').value);
        const cx = canvas.width / 2, cy = canvas.height / 2;
        
        const w = 340, h = 600; 

        let allCavityPoints = [];
        state.cavities.forEach(c => allCavityPoints.push(...c.shape));

        const points = [];
        const resolution = 180;
        const padding = 50;

        for (let i = 0; i < resolution; i++) {
            const angle = (i / resolution) * Math.PI * 2;
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);

            let rEllipse = Math.pow(Math.pow(Math.abs(cosA)/(w), 4) + Math.pow(Math.abs(sinA)/(h), 4), -1/4);
            rEllipse += Math.sin(i * 0.3 + state.contourSeed) * 15;

            let maxDist = 0;
            allCavityPoints.forEach(p => {
                const dx = p.x - cx;
                const dy = p.y - cy;
                const distAlongRay = dx * cosA + dy * sinA;
                
                const pAngle = Math.atan2(dy, dx);
                let dAngle = Math.abs(pAngle - angle);
                if (dAngle > Math.PI) dAngle = 2 * Math.PI - dAngle;

                if (dAngle < 0.2) { 
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) maxDist = dist;
                }
            });

            let rWrap = maxDist > 0 ? maxDist + padding : 100; 
            if(rWrap < 100) rWrap = 100;

            let rFinal = rEllipse * (1 - t) + rWrap * t;
            if(rFinal < rWrap) rFinal = rWrap; 

            const x = cx + cosA * rFinal;
            if(x < 5 || x > canvas.width - 5) {
                 rFinal = (canvas.width/2 - 10) / Math.abs(cosA);
            }

            points.push({ x: cx + cosA * rFinal, y: cy + sinA * rFinal });
        }
        
        state.talismanOutline = smoothPoints(points, 5);
        render();
    }
    
    // --- TEXTURE MIXER ---
    function generateTextureStack() {
        if (state.loadedTextures.length === 0) {
            state.activeTextureStack = [];
            return;
        }

        const stack = [];
        const layersCount = 3 + Math.floor(Math.random() * 3);
        
        for(let i=0; i<layersCount; i++) {
            const randTex = state.loadedTextures[Math.floor(Math.random() * state.loadedTextures.length)];
            const randMode = BLEND_MODES[Math.floor(Math.random() * BLEND_MODES.length)];
            const randOpacity = 0.2 + Math.random() * 0.6;
            
            stack.push({
                img: randTex,
                mode: randMode,
                opacity: randOpacity,
                flipX: Math.random() > 0.5,
                flipY: Math.random() > 0.5
            });
        }
        state.activeTextureStack = stack;
    }

    function generateFullTalisman() {
        state.contourSeed = Math.random() * 100;
        generateTextureStack();

        const num = parseInt(document.getElementById('windows').value);
        state.cavities = [];
        
        const cx = canvas.width / 2, cy = canvas.height / 2;
        for(let i=0; i<num; i++) {
            let placed = false, attempts = 0;
            while(!placed && attempts < 200) {
                const wx = cx + (Math.random()-0.5)*360; 
                const wy = cy + (Math.random()-0.5)*900;
                
                const size = 45 + Math.random() * 90;
                
                const safe = state.cavities.every(c => Math.hypot(c.x-wx, c.y-wy) > (c.size+size + 10));
                if(safe) {
                    state.cavities.push({ id: Date.now()+i, x: wx, y: wy, size: size, shape: generateCavityShape(wx, wy, size) });
                    placed = true;
                }
                attempts++;
            }
        }
        updateContourOnly();
    }

    // --- RENDER ---
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (state.talismanOutline.length === 0) return;
      const pts = state.talismanOutline;

      // 1. Shadow
      ctx.save(); ctx.translate(15, 30); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.filter = 'blur(20px)';
      ctx.beginPath(); pts.forEach((p,i) => i==0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
      ctx.fill(); ctx.restore();

      // 2. Stone Body
      ctx.save();
      ctx.beginPath(); pts.forEach((p,i) => i==0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
      ctx.clip();
      
      ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,canvas.width, canvas.height);
      
      if(state.activeTextureStack.length > 0) {
          state.activeTextureStack.forEach(layer => {
              ctx.save();
              ctx.globalCompositeOperation = layer.mode;
              ctx.globalAlpha = layer.opacity;
              if(layer.flipX || layer.flipY) {
                  ctx.translate(layer.flipX ? canvas.width : 0, layer.flipY ? canvas.height : 0);
                  ctx.scale(layer.flipX ? -1 : 1, layer.flipY ? -1 : 1);
              }
              ctx.drawImage(layer.img, 0, 0, canvas.width, canvas.height);
              ctx.restore();
          });
      } else {
          const grad = ctx.createRadialGradient(canvas.width/2-100, canvas.height/2-100, 50, canvas.width/2, canvas.height/2, 800);
          grad.addColorStop(0, '#666'); grad.addColorStop(1, '#222');
          ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height);
      }
      
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      
      const gradV = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 300, canvas.width/2, canvas.height/2, 800);
      gradV.addColorStop(0, 'rgba(0,0,0,0)'); gradV.addColorStop(1, 'rgba(0,0,0,0.8)');
      ctx.fillStyle = gradV; ctx.fillRect(0,0,canvas.width, canvas.height);

      ctx.restore();

      // 3. Cavities
      state.cavities.forEach(c => {
         ctx.save();
         ctx.beginPath(); c.shape.forEach((p,i) => i==0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
         ctx.fillStyle = '#050505'; ctx.fill();
         ctx.strokeStyle = (state.activeCavityId === c.id) ? '#8e44ad' : 'rgba(255,255,255,0.2)';
         ctx.lineWidth = (state.activeCavityId === c.id) ? 3 : 1;
         ctx.stroke();
         
         const asset = state.placedAssets[c.id];
         if(asset && state.images[asset.key]) {
             ctx.clip();
             const img = state.images[asset.key];
             const bounds = getBoundingBox(c.shape);
             const scale = Math.min(bounds.width/img.width, bounds.height/img.height) * asset.scale * 0.8;
             
             ctx.translate(bounds.cx, bounds.cy);
             ctx.rotate(asset.rot * Math.PI/180);
             ctx.drawImage(img, -img.width*scale/2, -img.height*scale/2, img.width*scale, img.height*scale);
         }
         ctx.restore();
      });
      
      // 4. Intention Text
      if(state.intentionText) {
          ctx.font = '40px "Stylish", sans-serif'; 
          ctx.fillStyle = '#aaa'; 
          ctx.textAlign = 'center'; 
          ctx.fillText(state.intentionText.toUpperCase(), canvas.width/2, canvas.height - 50);
      }
    }

    // --- ASSETS ---
    function loadSingleAsset(key, src, isCustom=false) {
        const img = new Image();
        img.crossOrigin = "Anonymous"; 
        img.src = src;
        img.onload = () => {
            state.images[key] = img;
            const div = document.createElement('div');
            div.className = 'asset-item' + (isCustom ? ' custom' : '');
            div.dataset.id = key;
            div.onclick = () => selectAsset(key);
            div.innerHTML = `<img src="${src}">`;
            document.getElementById('assetGrid').appendChild(div);
        };
    }

    function initAssets() {
        TEXTURE_FILENAMES.forEach(filename => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = TEXTURES_FOLDER + filename;
            img.onload = () => {
                state.loadedTextures.push(img);
                if(state.loadedTextures.length === 1) generateTextureStack(); render();
            };
        });
        
        SIGIL_FILENAMES.forEach((filename, i) => {
            loadSingleAsset('sigil_'+i, ASSETS_FOLDER + filename);
        });

        try {
            const saved = localStorage.getItem('talisman_custom_v3');
            if(saved) JSON.parse(saved).forEach(item => loadSingleAsset(item.id, item.src, true));
        } catch(e){}
    }
    
    // --- INTERACTION ---
    function selectAsset(key) {
        state.selectedAssetKey = key;
        document.querySelectorAll('.asset-item').forEach(el => el.classList.remove('selected'));
        const active = document.querySelector(`.asset-item[data-id="${key}"]`);
        if(active) active.classList.add('selected');
    }

    canvas.addEventListener('mousedown', handleInteract);
    canvas.addEventListener('touchstart', handleInteract);
    
    function handleInteract(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        const x = (clientX - rect.left) * (canvas.width / rect.width);
        const y = (clientY - rect.top) * (canvas.height / rect.height);

        const hit = state.cavities.find(c => isInside(x, y, c.shape));
        if(hit) {
            if(state.selectedAssetKey) {
                state.placedAssets[hit.id] = { key: state.selectedAssetKey, rot: 0, scale: 1.0 };
                render();
            }
            state.activeCavityId = hit.id;
            const acc = document.getElementById('acc-calibration');
            acc.classList.remove('disabled');
            if(!acc.classList.contains('active')) toggleAccordion('acc-calibration');
            render();
        } else {
            state.activeCavityId = null;
            render();
        }
    }
    
    document.getElementById('sigilRot').addEventListener('input', (e) => {
        if(state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            state.placedAssets[state.activeCavityId].rot = parseInt(e.target.value); render();
        }
    });
    document.getElementById('sigilScale').addEventListener('input', (e) => {
        if(state.activeCavityId && state.placedAssets[state.activeCavityId]) {
            state.placedAssets[state.activeCavityId].scale = parseFloat(e.target.value); render();
        }
    });
    document.getElementById('intentionInput').addEventListener('input', (e) => {
        state.intentionText = e.target.value; render();
    });
    
    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const id = 'custom_' + Date.now();
            loadSingleAsset(id, evt.target.result, true);
        };
        reader.readAsDataURL(file);
    }

    function exportImage() {
        const link = document.createElement('a');
        link.download = 'talisman.png';
        link.href = canvas.toDataURL();
        link.click();
    }
    
    function clearAssets() { state.placedAssets = {}; render(); }

    initAssets();
    generateFullTalisman();

    document.fonts.ready.then(function() {
      render();
    });

  </script>
</body>
</html>